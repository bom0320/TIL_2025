# Set과 React 상태 관리

## Set 이란

- Set 은 JS의 기본 내장 객체 중 하나로, "중복되지 않는 값들의 집합"을 저장할 수 있는 가변형(mutable) 자료구조이다.

```js
const s = new Set(["apple", "banana", "apple"]);
console.log(s);
// Set(2) {"apple" , "banana"}
```

- 같을 값을 여러 번 추가해도 한 번만 저장됨
- 인덱스로 접근은 불가능하고, 존재 여부를 빠르게 확인할 수 있다 (`Set.has(value)`)

## 중요한 점!

React에서 `Set` 은 참조형 객체(reference type) 이라서 직접 수정하면 React가 변화로 인식하지 않는다.

> 참조형 객체란?
>
> 객체의 실제 데이터가 아닌, 해당 객체가 저장된 메모리(힙 영역)의 주소를 가리키는 변수

즉, React 에서 아래처럼 코드를 작성하면 상태가 안 바뀐 것으로 인식한다.

```tsx
// React에선 이렇게 하면 안된다
matchedFruits.add("apple");
// -> 이건 새로운 Set을 만드는게 아니라 현재 같은 메모리 주소(예: 0x1001)에 있는 Set 내부 데이터를 수정하는 것
// 즉, 메모리 주소가 변하지 않음
setMatchedFruits(matchedFruits);
```

```tsx
// Before
matchedFruits (0x1001) -> Set {"banana"}

// After
matchedFruits (0x1001) -> Set {"banana", "apple"} // 주소는 그대로

```

React 입장에서는 "주소가 같은 객체"라서 "아직 상태가 안 바뀌었네?" 하고 리렌더링을 안한다.

### ⭐️ React에서는 "값"이 아닌 "객체의 참조(주소)" 를 본다.

React는 상태가 바뀌었는지 판단할때 값의 내용이 아니라, 객체의 참조(메모리 주소)가 바뀌었는지를 본다.

| 타입                                        | 비교 기준   | 예시             |
| ------------------------------------------- | ----------- | ---------------- |
| 원시값 (`number`, `string` 등)              | 값 자체     | `1 === 1` ok     |
| 참조형 (`Object`, `Array`, `Set`, `Map` 등) | 메모리 주소 | `{}` !== `{}` no |

즉, React는 "같은 주소인지"만 비교하지, 객체 안의 내용을 깊게 비교하지는 않는다. 그래서 객체를 직접 수정하면 주소가 그대로니까.. React 가 모르는 것

> 왜 굳이?
>
> React가 값 대신 주소(참조)를 보는 이유는 성능 때문이다. 내부 값을 하나씩 비교 하는건 너무 느리기 때문에, React는 **얕은 비교를 선택했다.**
> 즉, 주소(참조)가 달라지면 상태가 바뀌었다고 가정하는 설계를 채택했다. 따라서 우리는 React 의 철학에 맞춰서 개발자는 상태를 바꿀 때 마다, 개발자가 직접 상태를 바꾸는게 아닌, 새로운 객체를 만들어서 교체해줘야만 React가 올바르게 동작한다.

## 해결 방법

1. "불변 업데이트"하기

- 항상 새로운 Set 인스턴스를 만듬으로써 React가 변화를 인식하게 한다.

```tsx
// 추가
setMatchedFruits((prev) => {
  const next = new Set(prev); // 기존 Set 복사 -> 새 주소
  next.add("apple");
  return next; // React가 "새 객체"로 인식 -> 리렌더
});

// 시작
setMatchedFruits((prev) => {
  const next = new Set(prev);
  next.delete("apple");
  return next;
});

// 초기화
setMatchedFruits(new Set());
```

- 이렇게 하면 참조(주소)가 바뀌므로 React가 안전하게 리레더링 한다.
- 함수형 업데이트(prev => ...)를 사용하면 배치 업데이트에서도 안전

## Set vs Array vs Record<boolean>

| 자료형              | 중복 | 순서          | 장점                            | 단점                              |
| ------------------- | ---- | ------------- | ------------------------------- | --------------------------------- |
| **Set**             | 없음 | 중요하지 않음 | `has`, `add`, `delete` 빠름     | React 상태에서 불변 업데이트 불편 |
| **Array**           | 가능 | 순서 있음     | 순서/정렬 가능                  | 중복 관리 불편                    |
| **Record<boolean>** | 없음 | 키 고정       | 직렬화 쉬움, 불변 업데이트 간단 | 초기화 코드 약간 복잡             |

지금처럼 “과일을 한 번씩만 맞출 수 있는 게임”이라면

**Set**이 직관적이지만,

상태 직렬화나 의존성 관리가 중요하면 `Record<boolean>` 도 좋은 선택이다.
