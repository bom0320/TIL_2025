# 데이터센터 네트워크 아키텍처: 3계층 vs 2계층

# 3계층 디자인 (Core - Aggregation - Access)

### 1. Core (코어)

- 데이터센터 네트워크의 최상위 계층, 백본(Backbone)
- 모든 Aggregation에서 올라온 트래픽을 조합하고, 외부 인터넷
- 초고속 스위치 사용 (백플레인 대역폭이 매우 큼)
- **특징:** 장애가 나면 데이터센터 전체 서비스에 영향 → 이중화/고가용성 설계 필수

### 2. Aggregation (집약 계층)

- 여러 Access Switch들을 모아서 Core로 올려주는 중간 걔층
- VLAN 간 라우팅, 보안 정책 적용, 트래픽 제어, 로드밸런싱
- 특징:
  - 중간 허브 역할
  - 대규모 데이터센터에선 이 계층이 많아지면서 관리 복잡도 ↑

### 3. Access (접속 계층)

- 서버/PC/장비가 직접 연결되는 계층
- 예: 웹 서버 48대 → Access Switch 하나에 연결
- 가장 가까운 네트워크 장비, 서버들의 “첫 관문”

### 트래픽 흐름 (North-South Traffic)

- **North-South Traffic:** 내부 서버 ↔ 외부 인터넷 간의 트래픽
- 전통 3계층 구조는 이걸 가정하고 설계됨
  - 사용자가 웹 브라우저로 유튜브 접속 → 서버 응답
  - 회사 직원이 PC에서 이메일 서버 접속 → 인터넷 나감

과거에는 대부분 “내부 → 외부” 트래픽이 많았음

### 문제점 (전통 3계층 구조의 한계)

1. 서버 ↔ 서버 간 통신 (East-West Traffic) 비효율
   - 요즘 서비스(유튜브, 넷플릭스, 클라우드)는 서버 간 통신이 엄청 많음
   - 예: 앱 서버가 DB 서버랑, 캐시 서버랑, 스토리지 서버랑 계속 대화해야 함
   - 그런데 전통 구조에서는 서버끼리 통신해도 무조건 Core까지 갔다가 다시 내려옴
   - → 따라서 병**목 현상이 발생**하게 된다.
2. 계층이 많아 관리 복잡도 ↑
   - Access → Aggregation → Core를 거치다 보니 장비 수, 케이블 수도 많음
   - 트래픽 경로도 길어지고, 장애 시 복구도 복잡
3. 확장성 문제
   - 서버가 늘어나면 Access Switch → Aggregation → Core까지 다 증설해야 함
   - 데이터센터가 커질수록 비용과 복잡도가 기하급수적으로 커짐

---

# 2계층 디자인 (Spine-Leaf)

### 1. Leaf (잎)

- 서버가 직접 연결되는 스위치 (= Access Switch 역할)
- 모든 서버 (웹, 앱, DB, 스토리지 등)는 Leaf 스위치에 꽂임
- 각 Leaf 는 모든 Spine 과 연결되어 있어 → 어느 서버끼리든 “한번 Spine 거치면” 통신 가능

→ 즉 전통 Access Switch 랑 비슷하지만, Spine 과 직결된다는 게 차이

### 2. Spine (척추)

- 데이터센터의 중심 축 역할 (전통 구조의 Core Switch 대체)
- 모든 Leaf와 **풀 메쉬(Full Mesh)** 로 연결됨
- 트래픽이 몰리면, Spine 여러 대가 병렬도 동작해서 분산 처리
- Spine 많을 수록 성능/ 확장성이 좋아짐

→ “고속 고속도로” 같은 역할

## 트래픽 흐름: East-West Traffic

- East-West Traafic = 서버 ↔ 서버 간 통신
- 요즘은 외부 인터넷 (North-South)보다 서버끼리 대량으로 대화하는 게 훨씬 많음
  - 클라우드: VM ↔ VM 간 동기화
  - 빅데이터: 수천 대 서버가 동시에 데이터 교환 (Haddop, Spark)
  - AI: GPU 서버끼리 모델 파라미터 교환 (Distributed Training)

→ 즉, Spine-Leaf 이런 서버 간 대량 통신을 최적화한 구조라고 할 수 있다.

## Spine-Leaf 의 장점 (3계층 대비)

### 1. 경로 단순화 (Hop 수 일정)

- 서버 A ↔ 서버 B 통신 = 항상 “Leaf → Spine → Leaf” (2 hop)
- 경로가 짧고 예측 가능 → 지연 시간 낮음

### 2. 확장성 (Scalabilty)

- 서버가 늘어나면 Leaf 추가
- 트래픽이 늘어나면 Spine 추가
- 수정 확장이 쉬움 (Scale-out 구조)

### 3. 부하 분산

- Spine 여러 대 중에서 가장 덜 바쁜 Spine 을 자동 선택 (ECMP: Equal-Cost Multi-Path)
- 트래픽 몰림 방지

## 유튜브 예시 (Spine-Leaf에서 돌아가는 흐름)

- 유튜브 앱 서버가 DB 서버랑 대화할 때:
  → 앱 서버 → Leaf → Spine → Leaf → DB 서버
- 사용자가 영상을 클릭했을 때, 앱 서버가 스토리지 서버랑 대화:
  → 앱 서버 Leaf → Spine → 스토리지 Leaf → 스토리지 서버
- 서버끼리 직접 빠르게 통신 가능, Core 까지 올라갔다 내려올 필요 없음

### 정리하면

- Leaf = 서버 접속 지점 (Access 역할)
- Spine = 데이터센터 백본, 모든 Leaf 를 빠르게 연결 (Core 역할)
- 특징: 서버 ↔ 서버(East-West Traffic)에 최적화, 확장성 뛰어남 → 그래서 클라우드, 빅데이터, AI 데티어센터는 Spine-Leaf 구조를 거의 필수로 씀
